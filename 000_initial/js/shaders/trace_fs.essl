Shader.source[document.currentScript.src.split('js/shaders/')[1]]=`#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 tex;
in vec4 rayDir;
out vec4 fragmentColor;
uniform vec3 eyePosition;
uniform samplerCube background;
uniform samplerCube bricktexture;
uniform vec3 lightDirs[16];
uniform vec3 lightPoints[16]; 
uniform sampler3D volume;
uniform vec3 matCap;


float snoise(vec3 r) {
  r.xz *= 10.0;
  vec3 s = vec3(7502, 22777, 4767);
  float f = 0.0;
  for (int i=0; i<16; i++) {
    f+= sin( dot(s - vec3(32768, 32768, 32768), r) / 65536.0);
    s = mod(s,32768.0) * 2.0 + floor(s/32768.0);
  }
  return f/32.0 +0.5 -r.y;
}

float volumeF(vec3 r) {
  return texture(volume,vec3(r.x,r.y,r.z * (1. / matCap.y) ) ).r;
}

vec3 coliroze(vec4 hit,vec3 normal,vec4 brdfs,vec3 lightDir){
  //return normal;
  if(dot(normal,rayDir.xyz)>0.) normal=-normal;
  vec3 h=normalize(lightDir*-1.+rayDir.xyz);
  float blinn=dot(normal,h);
  blinn=pow(blinn,40.);
  //blinn= 0.;
  
  float phong=dot(normal,lightDir);
  if(phong>0.){
    vec4 dir=vec4(lightDir,0.)*1.;
    float bestT=-1.;
    int index=0;
      if(blinn>=0.){
        return brdfs.xyz*phong+vec3(1.,1.,1.)*blinn;
      }else{
        return brdfs.xyz*phong;
      }
  }
  return vec3(0.,0.,0.);
  
}

void collideBox(vec3 eye, vec3 dir, out float start, out float end) {
  float t1 = (1.0 - eye.x) / dir.x;
  float t2 = (0.0 - eye.x) / dir.x;
  float xstart = min(t1,t2);
  float xend = max(t1,t2);
  t1 = (1.0 - eye.y) / dir.y;
  t2 = (0.0 - eye.y) / dir.y;
  float ystart = min(t1,t2);
  float yend = max(t1,t2);
  t1 = (2.0 - eye.z) / dir.z;
  t2 = (0.0 - eye.z) / dir.z;
  float zstart = min(t1,t2);
  float zend = max(t1,t2);
  start = max(max(xstart,max(ystart,zstart)), 0.);
  end = max(min(xend,min(yend,zend)), 0.);
}

bool intersect(vec3 eye, vec3 d) {
  float tstart;
  float tend;
  collideBox(eye, d, tstart, tend);
  float h = 0.;
  vec3 p = eye + d * tstart;
  vec3 step =
    d * min((tend - tstart)/256.0, 0.05);
  for(int i=0; i<256; i++){
      h = volumeF(p);
      if( h > 0.1) return true;
      p += step;
      if (p.x > 1. || p.x < 0.) return false;
      if (p.y > 1. || p.y < 0.) return false;
      if (p.z > 2. || p.z < 0.) return false;
    }
  return false;
}

vec3 colirozeAll(vec4 hit,vec3 normal,vec4 brdfs){
  vec3 outColor = vec3(0,0,0);
  for(int i=0;i<1;i++){
    if (!intersect(hit.xyz - normal * 0.05, lightDirs[i].xyz)) {
      vec3 color=coliroze(hit,normal,brdfs,normalize(lightDirs[i]));
      outColor+=color*0.5;
    }
  }
  return outColor;
}

vec3 phong(float tstart, float tend, vec3 p, vec3 step, vec3 d, bool matCap) {
  float h = 0.;
 if ((tstart < tend)) {
   for(int i=0; i<128; i++){
      h = volumeF(p);
      if( h > 0.1) break;
      p += step;
      if (p.x > 1. || p.x < 0.) break;
      if (p.y > 1. || p.y < 0.) break;
      if (p.z > 2. || p.z < 0.) break;
    }
  }
  if (h > 0.0) {
    float epsilon = 0.01;
  vec3 gradient = vec3(
          volumeF(p + vec3(epsilon, 0.0, 0.0) ) -
          volumeF(p + vec3(-epsilon, 0.0, 0.0) ) ,
          volumeF(p + vec3(0.0, +epsilon, 0.0) ) -
          volumeF(p + vec3(0.0, -epsilon, 0.0) ) , 
          volumeF(p + vec3(0.0, 0.0, +epsilon) ) -
          volumeF(p + vec3(0.0, 0.0, -epsilon) ) 
          );
    vec3 normal = normalize(gradient);
    vec4 d2 = vec4(reflect(d, normal), 0.0);
    vec3 color = matCap ? texture(bricktexture, normal * -1.).xyz : vec3(1.,1.,0.);
    vec3 color2 = matCap ? color : colirozeAll(vec4(p,1.),normal,vec4(color,1.));
    return color2;
  } else {
    vec3 color = texture(background, d.xyz).xyz;
    return color;
  }
}

void main(void){
  vec3 d = normalize(rayDir.xyz);
  float tstart;
  float tend;
  collideBox(eyePosition, d, tstart, tend);
  vec3 p = eyePosition + d * tstart;
  vec3 step =
    d * min((tend - tstart)/128.0, 0.05);
    vec3 color = phong(tstart, tend, p, step, d, matCap.x < 0.1);
    fragmentColor = vec4(color, 1.);
}

`;