Shader.source[document.currentScript.src.split('js/shaders/')[1]]=`#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 tex;
in vec4 rayDir;
out vec4 fragmentColor;
uniform vec3 eyePosition;
uniform samplerCube background;
uniform samplerCube bricktexture;
uniform vec3 lightDirs[16];
uniform vec3 lightPoints[16]; 
uniform sampler3D volume;


float snoise(vec3 r) {
  r.xz *= 10.0;
  vec3 s = vec3(7502, 22777, 4767);
  float f = 0.0;
  for (int i=0; i<16; i++) {
    f+= sin( dot(s - vec3(32768, 32768, 32768), r) / 65536.0);
    s = mod(s,32768.0) * 2.0 + floor(s/32768.0);
  }
  return f/32.0 +0.5 -r.y;
}

float volumeF(vec3 r) {
  return texture(volume,r * -1.).r-0.2;
}

vec3 coliroze(vec4 hit,vec3 normal,vec4 brdfs,vec3 lightDir){
  //return normal;
  if(dot(normal,rayDir.xyz)>0.) normal=-normal;
  vec3 h=normalize(lightDir*-1.+rayDir.xyz);
  float blinn=dot(normal,h);
  blinn=pow(blinn,40.);
  //blinn= 0.;
  
  float phong=dot(normal,lightDir);
  if(phong>0.){
    vec4 dir=vec4(lightDir,0.)*1.;
    float bestT=-1.;
    int index=0;
      if(blinn>=0.){
        return brdfs.xyz*phong+vec3(1.,1.,1.)*blinn;
      }else{
        return brdfs.xyz*phong;
      }
  }
  return vec3(0.,0.,0.);
  
}

vec3 colirozeAll(vec4 hit,vec3 normal,vec4 brdfs){
  vec3 outColor = vec3(0,0,0);
  for(int i=0;i<3;i++){
    vec3 color=coliroze(hit,normal,brdfs,normalize(lightDirs[i]));
    outColor+=color*0.5;
  }
  return outColor;
}

void collideBox(vec3 eye, vec3 dir, out float start, out float end) {
  float t1 = (1.0 - eye.x) / dir.x;
  float t2 = (0.0 - eye.x) / dir.x;
  float xstart = max(min(t1,t2),0.);
  float xend = max(max(t1,t2),0.);
  t1 = (1.0 - eye.y) / dir.y;
  t2 = (0.0 - eye.y) / dir.y;
  float ystart = max(min(t1,t2),0.);
  float yend = max(max(t1,t2),0.);
  t1 = (1.0 - eye.z) / dir.z;
  t2 = (0.0 - eye.z) / dir.z;
  float zstart = max(min(t1,t2),0.);
  float zend = max(max(t1,t2),0.);

  start = xstart > 0. || ystart > 0. || zstart > 0. ? max(xstart,max(ystart,zstart)) : 0.;
  end =  xend > 0. || yend > 0. || zend > 0. ? min(xend,min(yend,zend)) : 0.;
}

void main(void){
  vec3 d = normalize(rayDir.xyz);
  float tstart;
  float tend;
  collideBox(eyePosition, d, tstart, tend);

  vec3 p = eyePosition + d * tstart;
  vec3 step =
    d * min((tend - tstart)/256.0, 0.05);
  float h = 1.;
  vec3 center = eyePosition + d * ((tend - tstart) / 2.);
  for(int i=0; i<256; i++){
      h = volumeF(p);
      if(h > 0.0) break;
      p += step;
      if (p.x > 1. || p.x < 0.) break;
      if (p.z > 1. || p.z < 0.) break;
    }
  if (h > 0.0) {
  vec3 gradient = vec3(
          volumeF(p + vec3(+0.05, 0.0, 0.0) ) -
          volumeF(p + vec3(-0.05, 0.0, 0.0) ) ,
          volumeF(p + vec3(0.0, +0.05, 0.0) ) -
          volumeF(p + vec3(0.0, -0.05, 0.0) ) , 
          volumeF(p + vec3(0.0, 0.0, +0.05) ) -
          volumeF(p + vec3(0.0, 0.0, -0.05) ) 
          );
    vec3 normal = normalize(gradient);
    vec4 d2 = vec4(reflect(d, normal), 0.0);
    vec3 color = texture(bricktexture, normal * -1.).xyz;
    vec3 color2 = colirozeAll(vec4(p,1.),normal,vec4(color,1.));
    fragmentColor = vec4(color,1.);
  } else {
    vec3 color = texture(background, d.xyz).xyz;
    fragmentColor = vec4(color,1.0);
  }
}

`;