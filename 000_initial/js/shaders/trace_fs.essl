Shader.source[document.currentScript.src.split('js/shaders/')[1]]=`#version 300 es
precision highp float;
precision highp sampler3D;

in vec2 tex;
in vec4 rayDir;
out vec4 fragmentColor;
uniform vec3 eyePosition;
uniform samplerCube background;
uniform vec3 lightDirs[16];
uniform vec3 lightPoints[16]; 
uniform sampler3D volume;


float snoise(vec3 r) {
  r.xz *= 10.0;
  vec3 s = vec3(7502, 22777, 4767);
  float f = 0.0;
  for (int i=0; i<16; i++) {
    f+= sin( dot(s - vec3(32768, 32768, 32768), r) / 65536.0);
    s = mod(s,32768.0) * 2.0 + floor(s/32768.0);
  }
  return f/32.0 +0.5 -r.y;
}

vec3 coliroze(vec4 hit,vec3 normal,vec4 brdfs,vec3 lightDir){
  
  if(dot(normal,rayDir.xyz)>0.)normal=-normal;
  vec3 h=normalize(lightDir*-1.+rayDir.xyz);
  float blinn=dot(normal,h);
  blinn=pow(blinn,40.);
  
  float phong=dot(normal,lightDir);
  if(phong>0.){
    vec4 dir=vec4(lightDir,0.)*1.;
    float bestT=-1.;
    int index=0;
      if(blinn>=0.){
        return brdfs.xyz*phong+vec3(1.,1.,1.)*blinn;
      }else{
        return brdfs.xyz*phong;
      }
  }
  return vec3(0.,0.,0.);
  
}

vec3 colirozeAll(vec4 hit,vec3 normal,vec4 brdfs){
  //texture(background, reflect(rayDir.xyz,normal));
  vec3 outColor = vec3(0,0,0);
  for(int i=0;i<16;i++){
    vec3 color=coliroze(hit,normal,brdfs,normalize(lightDirs[i]));
    outColor+=color;
  }
  for(int i=0;i<16;i++){
    vec3 color=coliroze(hit,normal,brdfs,normalize(lightPoints[i]-hit.xyz));
    outColor+=color;
  }
  return outColor;
}

void main(void){
  vec3 d = normalize(rayDir.xyz);

  float t1 = (1.0 - eyePosition.y) / d.y;
  float t2 = (0.0 - eyePosition.y) / d.y;
  float tstart = max(min(t1,t2), 0.0);
  float tend = max(max(t1,t2), 0.0);

  vec3 p = eyePosition + d * tstart;
  vec3 step =
    d * min((tend - tstart)/128.0, 0.05);
  float h;
  for(int i=0; i<128; i++){
      h = texture(volume, p).r;
      if(h > 0.0) break;
      p += step;
    }
  if (h >= 0.0) {
  vec3 gradient = vec3(
          snoise(p + vec3(+0.05, 0.0, 0.0) ) -
          snoise(p + vec3(-0.05, 0.0, 0.0) ) ,
          snoise(p + vec3(0.0, +0.05, 0.0) ) -
          snoise(p + vec3(0.0, -0.05, 0.0) ) , 
          snoise(p + vec3(0.0, 0.0, +0.05) ) -
          snoise(p + vec3(0.0, 0.0, -0.05) ) 
          );
    vec3 normal = normalize(gradient);
    vec4 d2 = vec4(reflect(d, normal), 0.0);
    vec3 color = texture(background, d2.xyz).xyz;
    fragmentColor = vec4(color,1.);
  } else {
    vec3 color = texture(background, d.xyz).xyz;
    fragmentColor = vec4(color,1.);
  }
}

`;